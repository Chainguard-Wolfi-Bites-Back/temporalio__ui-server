import{t as j}from"./translate.c28e5b4f.js";import{s as C,b as R}from"./data-encoder-config.6547a643.js";import{h as i,i as k}from"./has.0120f47d.js";import{v as S,a as O}from"./is-http.abcde6cd.js";import{s as W,p as q}from"./parse-with-big-int.0036a80a.js";async function B({payloads:e,namespace:o,settings:c,accessToken:r,encode:n=!1}){var u,m,P;const d=(u=c==null?void 0:c.codec)==null?void 0:u.endpoint,s=(m=c==null?void 0:c.codec)==null?void 0:m.passAccessToken,t=(P=c==null?void 0:c.codec)==null?void 0:P.includeCredentials,f={"Content-Type":"application/json","X-Namespace":o};if(s)if(S(d))f.Authorization=`Bearer ${r}`;else return C(),e;const T=t?{headers:f,credentials:"include",method:"POST",body:W(e)}:{headers:f,method:"POST",body:W(e)};return fetch(d+(n?"/encode":"/decode"),T).then(a=>{if(i(a,"ok")&&!a.ok)throw{statusCode:a.status,statusText:a.statusText,response:a,message:n?j("common.encode-failed"):j("common.decode-failed")};return a.json()}).then(a=>(R(),a)).catch(a=>(C(a),e))}const w=e=>Array.isArray(e)?e:[e];function l(e){var c;if(e===null)return e;const o=O(String(((c=e==null?void 0:e.metadata)==null?void 0:c.encoding)??""));if(e!=null&&e.metadata&&(e.metadata.encodingDecoded=o),o!=null&&o.startsWith("json/"))try{return q(O(String((e==null?void 0:e.data)??"")))}catch(r){console.warn("Could not parse payload: ",r)}return o==="binary/null"?null:e}const J=e=>{if(i(e,"searchAttributes")&&i(e.searchAttributes,"indexedFields")){const o=e.searchAttributes.indexedFields;Object.entries(o).forEach(([c,r])=>{o[c]=l(r)})}if(i(e,"memo")&&i(e.memo,"fields")){const o=e.memo.fields;Object.entries(o).forEach(([c,r])=>{o[c]=l(r)})}if(i(e,"header")&&i(e.header,"fields")){const o=e.header.fields;Object.entries(o).forEach(([c,r])=>{o[c]=l(r)})}if(i(e,"queryResult")){const o=e==null?void 0:e.queryResult;Object.entries(o).forEach(([c,r])=>{o[c]=l(r)})}return e},x=(e,o,c)=>async r=>{var n;if((n=o==null?void 0:o.codec)!=null&&n.endpoint){const d=await B({payloads:{payloads:r},namespace:e,settings:o,accessToken:c});return((d==null?void 0:d.payloads)??[]).map(l)}else return r.map(l)},h=(e,...o)=>{for(const c of o)if(e===c)return!0;return!1},E=async(e,o,c,r)=>{const n=x(o,c,r);if(e)for(const d of Object.keys(e))if(h(d,"payloads","encodedAttributes")&&e[d]){const s=w(e[d]),t=await n(s);e[d]=h(d,"encodedAttributes")?t[0]:t}else{const s=e[d];k(s)&&(e[d]=await E(s,o,c,r))}return e},F=async(e,o,c,r)=>{if(!e)return e;const n=x(o,c,r),d={...e};if(e)for(const s of Object.keys(d))if(h(s,"payloads","encodedAttributes")&&d[s]){const t=w(d[s]),f=await n(t);d[s]=h(s,"encodedAttributes")?f[0]:f}else{const t=d[s];k(t)&&(d[s]=await F(t,o,c,r))}return d},K=async({attributes:e,namespace:o,settings:c,accessToken:r})=>await E(e,o,c,r);export{l as a,B as b,K as c,J as d,F as e};
