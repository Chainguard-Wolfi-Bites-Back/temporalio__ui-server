import{aj as w}from"./index.bac36631.js";import{t as T}from"./translate.d045ded2.js";import{b as I,r as S,t as g}from"./time-format.9bc1d052.js";import{c as u}from"./format-camel-case.887ffc78.js";import{i as j}from"./index.99a6b2a9.js";import{a as A}from"./decode-payload.c3c0dce5.js";import{h as y,k as h}from"./has.d2b0b725.js";import{C as D}from"./is-event-type.591fd2b5.js";const R={key:"",value:""},O=new Set(["activityId","attempt","binaryChecksum","identity","parentInitiatedEventId","requestId","scheduledEventId","startedEventId","lastHeartbeatTime","scheduledTime","expirationTime"]),ot=t=>O.has(t),v=new Set(["suggestContinueAsNew","historySizeBytes"]),l=(t,e)=>!(e===null||e===void 0||e===""||e==="0s"||t==="type"||(!e||e==="0")&&v.has(t)),L=t=>!(t===null||t===void 0||t===""||Array.isArray(t)&&!t.length),nt=t=>typeof t=="string"?t:[t==null?void 0:t.payloads,t==null?void 0:t.indexedFields,t==null?void 0:t.points,t].find(e=>e!==void 0),G=t=>{if(h(t)){if(y(t,"stackTrace")&&t.stackTrace)return t.stackTrace;for(const e in t)if(h(t[e]))return G(t[e])}},K=["baseRunId","continuedExecutionRunId","firstExecutionRunId","newExecutionRunId","newRunId","originalExecutionRunId"],it=t=>{for(const e of K)if(t===e)return!0;return!1},N=["taskQueueName"],at=t=>{for(const e of N)if(t===e)return!0;return!1},Q=["workflowExecutionWorkflowId","workflowExecutionRunId"],ct=(t,e)=>{const r=!!(e!=null&&e.workflowExecutionWorkflowId&&(e!=null&&e.workflowExecutionRunId));for(const s of Q)if(t===s&&r)return!0;return!1},f=(t,e)=>{if(typeof e=="object"){const[r]=Object.keys(e);return r==="payloads"?{key:t,value:e}:{key:t+u(r),value:e[r]}}else return{key:t,value:e.toString()}},F=["failure","input","activityType","parentInitiatedEventId","workflowExecution","workflowType","taskQueue"],W=({attributes:t})=>{for(const[e,r]of Object.entries(t))if(l(e,r))return f(e,r)},C=t=>{if(y(t,"ActivityType"))return t.ActivityType;if(y(t,"activity_type"))return t.activity_type},P=t=>{var e,r,s;return!!((s=(r=(e=t.markerRecordedEventAttributes)==null?void 0:e.details)==null?void 0:r.type)!=null&&s.payloads)},x=t=>{var r,s,o,n,d,k;const e=W(t);if(D(t)){const i=(((o=(s=(r=t.markerRecordedEventAttributes)==null?void 0:r.details)==null?void 0:s.data)==null?void 0:o.payloads)||((k=(d=(n=t.markerRecordedEventAttributes)==null?void 0:n.details)==null?void 0:d.type)==null?void 0:k.payloads)||[]).map(b=>A(b)),a=i==null?void 0:i[0];if(P(t)&&a)return f("ActivityType",a);const p=C(a);if(p)return f("ActivityType",p)}for(const[c,i]of Object.entries(t.attributes))for(const a of F)if(c===a&&l(c,i))return f(c,i);return e},V=({lastEvent:t})=>x(t),ft=t=>t?j(t)?V(t):x(t):R,_=new Set(["header"]),$=new Set(["taskQueue","retryPolicy","parentWorkflowExecution","workflowExecution","meta"]),B=new Set(["maximumAttempts"]),m=T("workflows.unlimited"),q=T("workflows.no-expiration"),ut=(t,e)=>t===0?q:e,yt=(t,e)=>t?t-e:m,lt=t=>t||m,z=(t,e)=>t==="maximumAttempts"&&!e?m:e,M=(t,e)=>{if($.has(e)&&typeof t[e]=="object"){for(const[r,s]of Object.entries(t[e]))L(s)&&(B.has(r)?t[`${e}${u(r)}`]=z(r,s):t[`${e}${u(r)}`]=s);delete t[e]}},mt=(t,{compact:e}={compact:!1})=>{const r={};e&&(r.eventTime=I(t.eventTime,w(g),{relative:w(S)}));for(const[s,o]of Object.entries(t.attributes)){const n=l(s,o);!_.has(s)&&n&&(r[s]=o),M(r,s)}return r},E=["summary","parent","activity","taskQueue","schedule","retryPolicy","workflow","searchAttributes"],dt={activity:{label:"events.attribute-group.activity"},parent:{label:"events.attribute-group.parent"},retryPolicy:{label:"events.attribute-group.retry-policy"},schedule:{label:"events.attribute-group.schedule"},searchAttributes:{label:"events.attribute-group.search-attributes"},summary:{label:"events.attribute-group.summary"},taskQueue:{label:"events.attribute-group.task-queue"},workflow:{label:"events.attribute-group.workflow"}},H=(t,e)=>{var r,s;t.category==="activity"&&((r=e==null?void 0:e.activity)!=null&&r.length)&&(e.summary=[...e.activity,...e.summary],e.activity=[]),t.category==="activity"&&((s=e==null?void 0:e.workflow)!=null&&s.length)&&(e.summary=[...e.summary,...e.workflow],e.workflow=[])},J=t=>{const e=new Set(["summary","searchAttributes"]);for(const[r,s]of Object.entries(t))s.length===1&&!e.has(r)&&(t.summary=[...t.summary,...s],t[r]=[])},kt=(t,e)=>{const r={};E.forEach(s=>{s==="summary"?r[s]=Object.keys(e):r[s]=[]});for(const s in e){const o=E.find(n=>s.includes(n));o&&(r[o]=[s,...r[o]],r.summary=r.summary.filter(n=>n!==s))}return H(t,r),J(r),r};export{dt as a,G as b,ct as c,at as d,ot as e,mt as f,nt as g,kt as h,ft as i,ut as j,yt as k,x as l,lt as m,it as s};
