import{D as l}from"./scheduler.IHo1m08M.js";import{p as P}from"./stores.ImWCgP6N.js";import{g as k,d as w}from"./data-encoder.fdhIlA6b.js";import{a as R}from"./auth-user.fZcF2yBi.js";import{a as j}from"./atob.b0eKAuwS.js";import{i as C,h as i}from"./has.Hk4nWl3x.js";import{p as g}from"./parse-with-big-int.e3oI4SEy.js";const E=e=>Array.isArray(e)?e:[e];function f(e,c=!0){var o;if(e===null)return e;const s=j(String(((o=e==null?void 0:e.metadata)==null?void 0:o.encoding)??""));if(e!=null&&e.metadata&&(e.metadata.encodingDecoded=s),s!=null&&s.startsWith("json/"))try{const r=g(j(String((e==null?void 0:e.data)??"")));return c?r:{...e,data:r}}catch(r){console.warn("Could not parse payload: ",r)}return s==="binary/null"?c?null:{...e,data:null}:e}const K=(e,c=!0)=>{if(i(e,"searchAttributes")&&i(e.searchAttributes,"indexedFields")){const s=e.searchAttributes.indexedFields;Object.entries(s).forEach(([o,r])=>{s[o]=f(r,c)})}else if(i(e,"searchAttributes")){const s=e.searchAttributes;Object.entries(s).forEach(([o,r])=>{s[o]=f(r,c)})}if(i(e,"memo")&&i(e.memo,"fields")){const s=e.memo.fields;Object.entries(s).forEach(([o,r])=>{s[o]=f(r,c)})}if(i(e,"header")&&i(e.header,"fields")){const s=e.header.fields;Object.entries(s).forEach(([o,r])=>{s[o]=f(r,c)})}if(i(e,"queryResult")){const s=e==null?void 0:e.queryResult;Object.entries(s).forEach(([o,r])=>{s[o]=f(r,c)})}return e},W=e=>async(c,s=!0)=>{if(k(e)){const o=await w({payloads:{payloads:c},settings:e});return((o==null?void 0:o.payloads)??[]).map(r=>f(r,s))}else return c.map(o=>f(o,s))},q=e=>async c=>{if(k(e)){const s=await w({payloads:{payloads:c},settings:e});return(s==null?void 0:s.payloads)??[]}else return c},h=(e,...c)=>{for(const s of c)if(e===s)return!0;return!1},x=async(e,c=l(P).params.namespace,s=l(P).data.settings,o=l(R).accessToken)=>{const r=W(s);if(e)for(const d of Object.keys(e))if(h(d,"payloads","encodedAttributes")&&e[d]){const t=E(e[d]),a=await r(t);e[d]=h(d,"encodedAttributes")?a[0]:a}else{const t=e[d];C(t)&&(e[d]=await x(t,c,s,o))}return e},_=async(e,c,s,o,r="readable",d=!0)=>{if(!e)return e;const t=r==="readable"?W(s):q(s),a={...e};if(e)for(const n of Object.keys(a))if(h(n,"payloads","encodedAttributes")&&a[n]){const m=E(a[n]),u=await t(m,d);a[n]=h(n,"encodedAttributes")?u[0]:u}else{const m=a[n];C(m)&&(a[n]=await _(m,c,s,o,r,d))}return a},O=async({attributes:e,namespace:c,settings:s,accessToken:o})=>await x(e,c,s,o);export{O as a,f as b,_ as c,K as d};
