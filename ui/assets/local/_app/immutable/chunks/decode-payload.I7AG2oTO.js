import{D as h}from"./scheduler.CFZRjJlR.js";import{p as u}from"./stores.QfhnIRtk.js";import{g as C,d as E}from"./data-encoder.Y4e4QFrB.js";import{a as W}from"./auth-user.ZbRaNYt5.js";import{a as j}from"./atob.b0eKAuwS.js";import{h as f,i as P}from"./has.Hk4nWl3x.js";import{p as x}from"./parse-with-big-int.e3oI4SEy.js";const g=e=>Array.isArray(e)?e:[e];function n(e,r=!0){var o;if(e===null)return e;const s=j(String(((o=e==null?void 0:e.metadata)==null?void 0:o.encoding)??""));if(e!=null&&e.metadata&&(e.metadata.encodingDecoded=s),s!=null&&s.startsWith("json/"))try{const c=x(j(String((e==null?void 0:e.data)??"")));return r?c:{...e,data:c}}catch(c){console.warn("Could not parse payload: ",c)}return s==="binary/null"?r?null:{...e,data:null}:e}const J=(e,r=!0)=>{if(f(e,"searchAttributes")&&f(e.searchAttributes,"indexedFields")){const s=e.searchAttributes.indexedFields;Object.entries(s).forEach(([o,c])=>{s[o]=n(c,r)})}else if(f(e,"searchAttributes")){const s=e.searchAttributes;Object.entries(s).forEach(([o,c])=>{s[o]=n(c,r)})}if(f(e,"memo")&&f(e.memo,"fields")){const s=e.memo.fields;Object.entries(s).forEach(([o,c])=>{s[o]=n(c,r)})}if(f(e,"header")&&f(e.header,"fields")){const s=e.header.fields;Object.entries(s).forEach(([o,c])=>{s[o]=n(c,r)})}if(f(e,"queryResult")){const s=e==null?void 0:e.queryResult;Object.entries(s).forEach(([o,c])=>{s[o]=n(c,r)})}return e},k=e=>async(r,s=!0)=>{if(C(e)){const o=await E({payloads:{payloads:r},settings:e});return((o==null?void 0:o.payloads)??[]).map(c=>n(c,s))}else return r.map(o=>n(o,s))},m=(e,...r)=>{for(const s of r)if(e===s)return!0;return!1},w=async(e,r=h(u).params.namespace,s=h(u).data.settings,o=h(W).accessToken)=>{const c=k(s);if(e)for(const a of Object.keys(e))if(m(a,"payloads","encodedAttributes")&&e[a]){const d=g(e[a]),i=await c(d);e[a]=m(a,"encodedAttributes")?i[0]:i}else{const d=e[a];P(d)&&(e[a]=await w(d,r,s,o))}return e},q=async(e,r,s,o,c=!0)=>{if(!e)return e;const a=k(s),d={...e};if(e)for(const i of Object.keys(d))if(m(i,"payloads","encodedAttributes")&&d[i]){const t=g(d[i]),l=await a(t,c);d[i]=m(i,"encodedAttributes")?l[0]:l}else{const t=d[i];P(t)&&(d[i]=await q(t,r,s,o,c))}return d},K=async({attributes:e,namespace:r,settings:s,accessToken:o})=>await w(e,r,s,o);export{K as a,n as b,q as c,J as d};
