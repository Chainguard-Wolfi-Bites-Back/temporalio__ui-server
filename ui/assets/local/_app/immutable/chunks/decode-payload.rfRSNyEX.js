import{C as t}from"./scheduler.AWtTlMeO.js";import{p as l}from"./stores.VlF-1afR.js";import{t as w}from"./translate.HrioCK44.js";import{a as p}from"./auth-user.R3tTGEiR.js";import{c as P,o as j,p as F,i as _,v as x,s as T,a as R,b as O}from"./data-encoder-config.BxbXIGq5.js";import{h,j as W}from"./has.-dFYEuQV.js";import{s as C,p as z}from"./parse-with-big-int.e3oI4SEy.js";const E=(e,n=P,o=j)=>{var s;return t(o)&&t(n)||((s=e==null?void 0:e.codec)==null?void 0:s.endpoint)||t(n)||""},S=(e,n=F,o=P,c=j)=>{var r,d;const s=t(c)&&t(o),a=(r=e==null?void 0:e.codec)!=null&&r.endpoint?!!((d=e==null?void 0:e.codec)!=null&&d.passAccessToken):!!t(n);return s?!!t(n):a},b=(e,n=_,o=P,c=j)=>{var r,d;const s=t(c)&&t(o),a=(r=e==null?void 0:e.codec)!=null&&r.endpoint?!!((d=e==null?void 0:e.codec)!=null&&d.includeCredentials):!!t(n);return s?!!t(n):a};async function L({payloads:e,namespace:n=t(l).params.namespace,settings:o=t(l).data.settings}){const c=E(o),s=S(o),a=b(o),r={"Content-Type":"application/json","X-Namespace":n};if(s)if(x(c)){let i=t(p).accessToken;globalThis!=null&&globalThis.AccessToken&&(i=await(globalThis==null?void 0:globalThis.AccessToken())),r.Authorization=`Bearer ${i}`}else return T(),e;const d=a?{headers:r,credentials:"include",method:"POST",body:C(e)}:{headers:r,method:"POST",body:C(e)};return fetch(c+"/decode",d).then(i=>{if(h(i,"ok")&&!i.ok)throw{statusCode:i.status,statusText:i.statusText,response:i,message:w("common.decode-failed")};return i.json()}).then(i=>(R(),i)).catch(i=>(T(i),e))}async function G({payloads:e,namespace:n=t(l).params.namespace,settings:o=t(l).data.settings,accessToken:c=t(p).accessToken}){const s=E(o),a=S(o),r=b(o),d={"Content-Type":"application/json","X-Namespace":n};if(a)if(x(s))d.Authorization=`Bearer ${c}`;else return T(),e;const u=r?{headers:d,credentials:"include",method:"POST",body:C(e)}:{headers:d,method:"POST",body:C(e)};return fetch(s+"/encode",u).then(f=>{if(h(f,"ok")&&!f.ok)throw{statusCode:f.status,statusText:f.statusText,response:f,message:w("common.encode-failed")};return f.json()}).then(f=>(R(),f)).catch(f=>{throw T(f),f})}const q=e=>Array.isArray(e)?e:[e];function m(e,n=!0){var c;if(e===null)return e;const o=O(String(((c=e==null?void 0:e.metadata)==null?void 0:c.encoding)??""));if(e!=null&&e.metadata&&(e.metadata.encodingDecoded=o),o!=null&&o.startsWith("json/"))try{const s=z(O(String((e==null?void 0:e.data)??"")));return n?s:{...e,data:s}}catch(s){console.warn("Could not parse payload: ",s)}return o==="binary/null"?n?null:{...e,data:null}:e}const M=(e,n=!0)=>{if(h(e,"searchAttributes")&&h(e.searchAttributes,"indexedFields")){const o=e.searchAttributes.indexedFields;Object.entries(o).forEach(([c,s])=>{o[c]=m(s,n)})}else if(h(e,"searchAttributes")){const o=e.searchAttributes;Object.entries(o).forEach(([c,s])=>{o[c]=m(s,n)})}if(h(e,"memo")&&h(e.memo,"fields")){const o=e.memo.fields;Object.entries(o).forEach(([c,s])=>{o[c]=m(s,n)})}if(h(e,"header")&&h(e.header,"fields")){const o=e.header.fields;Object.entries(o).forEach(([c,s])=>{o[c]=m(s,n)})}if(h(e,"queryResult")){const o=e==null?void 0:e.queryResult;Object.entries(o).forEach(([c,s])=>{o[c]=m(s,n)})}return e},B=e=>async(n,o=!0)=>{if(E(e)){const c=await L({payloads:{payloads:n},settings:e});return((c==null?void 0:c.payloads)??[]).map(s=>m(s,o))}else return n.map(c=>m(c,o))},k=(e,...n)=>{for(const o of n)if(e===o)return!0;return!1},I=async(e,n=t(l).params.namespace,o=t(l).data.settings,c=t(p).accessToken)=>{const s=B(o);if(e)for(const a of Object.keys(e))if(k(a,"payloads","encodedAttributes")&&e[a]){const r=q(e[a]),d=await s(r);e[a]=k(a,"encodedAttributes")?d[0]:d}else{const r=e[a];W(r)&&(e[a]=await I(r,n,o,c))}return e},N=async(e,n,o,c,s=!0)=>{if(!e)return e;const a=B(o),r={...e};if(e)for(const d of Object.keys(r))if(k(d,"payloads","encodedAttributes")&&r[d]){const u=q(r[d]),i=await a(u,s);r[d]=k(d,"encodedAttributes")?i[0]:i}else{const u=r[d];W(u)&&(r[d]=await N(u,n,o,c,s))}return r},Q=async({attributes:e,namespace:n,settings:o,accessToken:c})=>await I(e,n,o,c);export{S as a,b,N as c,M as d,G as e,Q as f,E as g,m as h};
