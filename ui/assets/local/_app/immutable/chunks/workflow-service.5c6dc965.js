import{W as U,n as k}from"./index.e1c99c2b.js";import{b as Q}from"./decode-payload.96ba378b.js";import{c as F}from"./is.ba28a1ea.js";import{s as $}from"./settings.612a0433.js";import{s as q}from"./simplify-attributes.26aa39ce.js";import{B as N}from"./route-for.2fd91e36.js";import{b as _,p as j,a as u,r as w,c as D,i as L,d as V}from"./route-for-api.417662c9.js";import{s as x}from"./parse-with-big-int.bccd89af.js";import{t as G}from"./list-workflow-query.c4fb30b1.js";import{v as H}from"./toaster.7dc81cff.js";const J=(o=$)=>!U(o).disableWriteActions,K=(o=[])=>o.map(t=>{const n=q(t,!0),r=t.activityId;return{...n,id:r}}),M=o=>F(o)||F(o.indexedFields)?{}:{indexedFields:Object.entries(o.indexedFields).reduce((n,[r,e])=>({...n,[r]:Q(e)}),{})},y=o=>{var I,g,b,W,T,A,S;const t=M(o.workflowExecutionInfo.searchAttributes),n=o.workflowExecutionInfo.type.name,r=o.workflowExecutionInfo.execution.workflowId,e=o.workflowExecutionInfo.execution.runId,i=o.workflowExecutionInfo.startTime,c=o.workflowExecutionInfo.closeTime,a=o.workflowExecutionInfo.executionTime,l=o.workflowExecutionInfo.status,f=o.workflowExecutionInfo.status==="Running",d=o.workflowExecutionInfo.historyLength,E=o.workflowExecutionInfo.historySizeBytes,s=`/workflows/${r}/${e}`,m=((g=(I=o==null?void 0:o.executionConfig)==null?void 0:I.taskQueue)==null?void 0:g.name)||((b=o==null?void 0:o.workflowExecutionInfo)==null?void 0:b.taskQueue),h=(W=o==null?void 0:o.workflowExecutionInfo)==null?void 0:W.mostRecentWorkerVersionStamp,v=(T=o==null?void 0:o.workflowExecutionInfo)==null?void 0:T.parentNamespaceId,C=(A=o==null?void 0:o.workflowExecutionInfo)==null?void 0:A.parentExecution,O=o.workflowExecutionInfo.stateTransitionCount,z=(S=o.executionConfig)==null?void 0:S.defaultWorkflowTaskTimeout,R=K(o.pendingActivities),B=(o==null?void 0:o.pendingChildren)??[];return{name:n,id:r,runId:e,startTime:i,endTime:c,executionTime:a,status:l,historyEvents:d,historySizeBytes:E,searchAttributes:t,url:s,taskQueue:m,mostRecentWorkerVersionStamp:h,pendingActivities:R,pendingChildren:B,parentNamespaceId:v,parent:C,stateTransitionCount:O,isRunning:f,defaultWorkflowTaskTimeout:z,get canBeTerminated(){return f&&J()}}},p=o=>(o.executions||[]).map(t=>y({workflowExecutionInfo:t})),X=o=>window.btoa(encodeURIComponent(o).replace(/%([0-9A-F]{2})/g,(t,n)=>String.fromCharCode(parseInt(n,16)))),P=(o,t=N)=>t?X(o):o,fo=async(o,t,n=fetch)=>{let r=0,e=0;try{const i=w("workflows.count",{namespace:o});if(t){const c=u(i,{params:{query:t},onError:k,handleError:k,request:n}),a=u(i,{params:{query:""},onError:k,handleError:k,request:n}),[l,f]=await Promise.all([c,a]);e=parseInt((l==null?void 0:l.count)??"0"),r=parseInt(f==null?void 0:f.count)}else{const c=await u(i,{params:{},onError:k,handleError:k,request:n});r=parseInt(c==null?void 0:c.count)}}catch{}return{count:e,totalCount:r}},Y=async(o,t,n=fetch,r=!1)=>{const e=t.query||G(t,r);let i;try{i=decodeURIComponent(e)}catch{i=e}const c=r?"workflows.archived":"workflows";let a="";const l=s=>{var m,h;D(s),(m=s==null?void 0:s.body)!=null&&m.message||s!=null&&s.status?a=((h=s==null?void 0:s.body)==null?void 0:h.message)??`Error fetching workflows: ${s.status}: ${s.statusText}`:a="Error fetching workflows: Server failed to respond"},f=w(c,{namespace:o}),{executions:d,nextPageToken:E}=await u(f,{params:{query:i},onError:l,handleError:l,request:n})??{executions:[],nextPageToken:""};return{workflows:p({executions:d}),nextPageToken:String(E),error:a}},uo=async({namespace:o,workflowId:t,url:n},r=fetch)=>{var d;const e="workflows",i=n??_(o),c=j(e,{namespace:o}),a=i+c,{executions:l}=await u(a,{params:{query:`WorkflowId="${t}"`,pageSize:"1"},request:r})??{executions:[]},f=(d=p({executions:l}))==null?void 0:d[0];return{runId:f==null?void 0:f.runId}},lo=async(o,t=fetch,n=!1)=>{const r=n?"workflows.archived":"workflows";let e=!0;const i=a=>{(L(a)||V(a))&&(e=!1)},c=w(r,{namespace:o});return await u(c,{params:{pageSize:"1"},onError:i,handleError:i,request:t}),{authorized:e}},wo=async(o,t,n=fetch)=>Y(o,t,n,!0);async function ko(o,t=fetch){const n=w("workflow",o);return u(n,{request:t}).then(y)}async function mo({workflow:o,namespace:t,reason:n,identity:r}){const e=w("workflow.terminate",{namespace:t,workflowId:o.id,runId:o.runId});return await u(e,{options:{method:"POST",body:x({reason:n,...r&&{identity:r}})},notifyOnError:!1})}async function ho({namespace:o,workflowId:t,runId:n},r=fetch){const e=w("workflow.cancel",{namespace:o,workflowId:t,runId:n});return u(e,{request:r,notifyOnError:!1,options:{method:"POST"}})}async function Eo({namespace:o,workflowId:t,runId:n,signalName:r,signalInput:e}){const i=w("workflow.signal",{namespace:o,workflowId:t,runId:n});return u(i,{notifyOnError:!1,options:{method:"POST",body:x({signalName:r,input:{payloads:e?[{metadata:{encoding:P("json/plain")},data:P(e)}]:null}})}})}async function xo({namespace:o,workflowId:t,runId:n,eventId:r,reason:e,resetReapplyType:i}){const c=w("workflow.reset",{namespace:o,workflowId:t,runId:n}),a={workflowExecution:{workflowId:t,runId:n},workflowTaskFinishEventId:r,resetReapplyType:i,requestId:H(),reason:e};return u(c,{notifyOnError:!1,options:{method:"POST",body:x(a)}})}async function yo(o,t=fetch){const n=e=>{console.error(e)},r=w("workflow",o);return u(r,{request:t,onError:n,handleError:n}).then(y)}export{Y as a,fo as b,ho as c,lo as d,wo as e,ko as f,yo as g,uo as h,xo as r,Eo as s,mo as t,J as w};
