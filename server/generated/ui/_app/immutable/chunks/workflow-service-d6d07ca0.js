import{a7 as v,B as d}from"./index-3630b6f8.js";import{s as C}from"./settings-78a38e6a.js";import{s as S}from"./simplify-attributes-79e997c9.js";import{r as u,a as s,b as O,i as F,c as z}from"./route-for-api-ccb80f4c.js";import{t as U}from"./list-workflow-query-3eb8d617.js";import{s as h}from"./parse-with-big-int-02e81897.js";import{e as $}from"./route-for-9e2a964e.js";import{v as B}from"./toaster-ae3b14ff.js";const Q=(o=C)=>!v(o).disableWriteActions,R=(o=[])=>o.map(t=>{const n=S(t,!0),r=t.activityId;return{...n,id:r}}),g=o=>{var y,x,I,T,b;const t=o.workflowExecutionInfo.type.name,n=o.workflowExecutionInfo.execution.workflowId,r=o.workflowExecutionInfo.execution.runId,a=String(o.workflowExecutionInfo.startTime),i=String(o.workflowExecutionInfo.closeTime),e=o.workflowExecutionInfo.status,f=o.workflowExecutionInfo.status==="Running",l=o.workflowExecutionInfo.historyLength,w=`/workflows/${n}/${r}`,E=(x=(y=o==null?void 0:o.executionConfig)==null?void 0:y.taskQueue)==null?void 0:x.name,c=(I=o==null?void 0:o.workflowExecutionInfo)==null?void 0:I.parentNamespaceId,k=(T=o==null?void 0:o.workflowExecutionInfo)==null?void 0:T.parentExecution,m=o.workflowExecutionInfo.stateTransitionCount,A=(b=o.executionConfig)==null?void 0:b.defaultWorkflowTaskTimeout,p=R(o.pendingActivities),P=(o==null?void 0:o.pendingChildren)??[];return{name:t,id:n,runId:r,startTime:a,endTime:i,status:e,historyEvents:l,url:w,taskQueue:E,pendingActivities:p,pendingChildren:P,parentNamespaceId:c,parent:k,stateTransitionCount:m,isRunning:f,defaultWorkflowTaskTimeout:A,get canBeTerminated(){return f&&Q()}}},_=o=>(o.executions||[]).map(t=>g({workflowExecutionInfo:t})),q=o=>window.btoa(encodeURIComponent(o).replace(/%([0-9A-F]{2})/g,(t,n)=>String.fromCharCode(parseInt(n,16)))),W=(o,t=$)=>t?q(o):o,V=async(o,t,n=fetch)=>{let r=0,a=0;try{const i=await u("workflows.count",{namespace:o});if(t){const e=s(i,{params:{query:t},onError:d,handleError:d,request:n}),f=s(i,{params:{query:""},onError:d,handleError:d,request:n}),[l,w]=await Promise.all([e,f]);a=l==null?void 0:l.count,r=w==null?void 0:w.count}else{const e=await s(i,{params:{},onError:d,handleError:d,request:n});r=e==null?void 0:e.count}}catch{}return{count:a,totalCount:r}},D=async(o,t,n=fetch,r=!1)=>{const a=decodeURIComponent(t.query||U(t,r)),i=r?"workflows.archived":"workflows";let e="";const f=c=>{var k,m;O(c),(k=c==null?void 0:c.body)!=null&&k.message||c!=null&&c.status?e=((m=c==null?void 0:c.body)==null?void 0:m.message)??`Error fetching workflows: ${c.status}: ${c.statusText}`:e="Error fetching workflows: Server failed to respond"},l=await u(i,{namespace:o}),{executions:w,nextPageToken:E}=await s(l,{params:{query:a},onError:f,handleError:f,request:n})??{executions:[],nextPageToken:""};return{workflows:_({executions:w}),nextPageToken:String(E),error:e}},X=async(o,t=fetch,n=!1)=>{const r=n?"workflows.archived":"workflows";let a=!0;const i=f=>{(F(f)||z(f))&&(a=!1)},e=await u(r,{namespace:o});return await s(e,{params:{pageSize:"1"},onError:i,handleError:i,request:t}),{authorized:a}},Y=async(o,t,n=fetch)=>D(o,t,n,!0);async function Z(o,t=fetch){const n=await u("workflow",o);return s(n,{request:t}).then(g)}async function oo({workflow:o,namespace:t,reason:n}){const r=await u("workflow.terminate",{namespace:t,workflowId:o.id,runId:o.runId});return await s(r,{options:{method:"POST",body:h({reason:n})},shouldRetry:!1,notifyOnError:!1})}async function to({namespace:o,workflowId:t,runId:n},r=fetch){const a=await u("workflow.cancel",{namespace:o,workflowId:t,runId:n});return s(a,{request:r,notifyOnError:!1,options:{method:"POST"}})}async function no({namespace:o,workflowId:t,runId:n,signalName:r,signalInput:a}){const i=await u("workflow.signal",{namespace:o,workflowId:t,runId:n});return s(i,{notifyOnError:!1,options:{method:"POST",body:h({signalName:r,input:{payloads:a?[{metadata:{encoding:W("json/plain")},data:W(h(a))}]:null}})}})}async function ro({namespace:o,workflowId:t,runId:n,eventId:r,reason:a}){const i=await u("workflow.reset",{namespace:o,workflowId:t,runId:n}),e={workflowExecution:{workflowId:t,runId:n},workflowTaskFinishEventId:r,requestId:B(),reason:a};return s(i,{notifyOnError:!1,options:{method:"POST",body:h(e)}})}async function ao(o,t=fetch){const n=a=>{console.error(a)},r=await u("workflow",o);return s(r,{request:t,onError:n,handleError:n}).then(g)}export{D as a,V as b,to as c,X as d,Y as e,Z as f,ao as g,ro as r,no as s,oo as t,Q as w};
