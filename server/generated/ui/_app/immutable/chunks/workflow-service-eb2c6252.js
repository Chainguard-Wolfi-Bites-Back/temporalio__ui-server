import{a7 as $}from"./index-e693a59e.js";import{s as C}from"./settings-6e0607c4.js";import{s as D}from"./simplify-attributes-ff333df4.js";import{r as g,a as x,b as F,i as q,c as z}from"./route-for-api-2a8bef97.js";import{i as K,b as P,t as b,c as Q}from"./format-date-016d7451.js";const R=(t=C)=>!$(t).disableWriteActions,N=(t=[])=>t.map(o=>{const n=D(o,!0),i=o.activityId;return{...n,id:i}}),W=t=>{var E,h,y,T,I,A;const o=t.workflowExecutionInfo.type.name,n=t.workflowExecutionInfo.execution.workflowId,i=t.workflowExecutionInfo.execution.runId,s=String(t.workflowExecutionInfo.startTime),c=String(t.workflowExecutionInfo.closeTime),a=t.workflowExecutionInfo.status,r=t.workflowExecutionInfo.status==="Running",d=t.workflowExecutionInfo.historyLength,k=`/workflows/${n}/${i}`,m=(h=(E=t==null?void 0:t.executionConfig)==null?void 0:E.taskQueue)==null?void 0:h.name,f=(y=t==null?void 0:t.workflowExecutionInfo)==null?void 0:y.parentNamespaceId,e=(T=t==null?void 0:t.workflowExecutionInfo)==null?void 0:T.parentExecution,u=t.workflowExecutionInfo.stateTransitionCount,l=(I=t.executionConfig)==null?void 0:I.defaultWorkflowTaskTimeout,w=N(t.pendingActivities),S=(A=t==null?void 0:t.pendingChildren)!=null?A:[];return{name:o,id:n,runId:i,startTime:s,endTime:c,status:a,historyEvents:d,url:k,taskQueue:m,pendingActivities:w,pendingChildren:S,parentNamespaceId:f,parent:e,stateTransitionCount:u,isRunning:r,defaultWorkflowTaskTimeout:l,get canBeTerminated(){return r&&R()}}},p=t=>(t.executions||[]).map(o=>W({workflowExecutionInfo:o})),B={workflowId:"WorkflowId",workflowType:"WorkflowType",timeRange:"StartTime",executionStatus:"ExecutionStatus",closeTime:"CloseTime"},U=["workflowId","workflowType","timeRange","executionStatus","closeTime"],j=t=>!(t===null||t===void 0||t===""||typeof t=="string"&&t==="undefined"),L=t=>{if(typeof t!="string")return!1;for(const o of U)if(o===t)return!0;return!1},O=(t,o,n)=>{const i=B[t];return o==="All"?"":K(o)||P(o)?n?`${i} > "${b(o)}"`:`${i} BETWEEN "${b(o)}" AND "${Q()}"`:`${i}="${o}"`},_=(t,o)=>Object.entries(t).map(([n,i])=>{if(L(n)&&j(i))return O(n,i,o)}).filter(Boolean),V=(t,o=!1)=>_(t,o).join(" and "),G=async(t,o,n=fetch,i=!1)=>{var f;const s=decodeURIComponent(o.query||V(o,i)),c=i?"workflows.archived":"workflows";let a="";const r=e=>{var u,l,w;F(e),((u=e==null?void 0:e.body)==null?void 0:u.message)||(e==null?void 0:e.status)?a=(w=(l=e==null?void 0:e.body)==null?void 0:l.message)!=null?w:`Error fetching workflows: ${e.status}: ${e.statusText}`:a="Error fetching workflows: Server failed to respond"},d=await g(c,{namespace:t}),{executions:k,nextPageToken:m}=(f=await x(d,{params:{query:s},onError:r,handleError:r,request:n}))!=null?f:{executions:[],nextPageToken:""};return{workflows:p({executions:k}),nextPageToken:String(m),error:a}},Z=async(t,o=fetch,n=!1)=>{const i=n?"workflows.archived":"workflows";let s=!0;const c=r=>{(q(r)||z(r))&&(s=!1)},a=await g(i,{namespace:t});return await x(a,{params:{pageSize:"1"},onError:c,handleError:c,request:o}),{authorized:s}},v=async(t,o,n=fetch)=>G(t,o,n,!0);async function tt(t,o=fetch){const n=await g("workflow",t);return x(n,{request:o}).then(W)}export{G as a,Z as b,v as c,tt as f,V as t};
