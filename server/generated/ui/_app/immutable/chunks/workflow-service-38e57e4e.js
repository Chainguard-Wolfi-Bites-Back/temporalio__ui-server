import{a7 as p,F as d}from"./index-92fe1086.js";import{s as P}from"./settings-094bc836.js";import{s as C}from"./simplify-attributes-e9cbffa0.js";import{r as w,a as f,b as F,i as D,c as O}from"./route-for-api-a26fa800.js";import{h as z,j as K,k as b,l as Q}from"./format-time-63ab2d37.js";import{s as B}from"./parse-with-big-int-561ccb8b.js";const N=(t=P)=>!p(t).disableWriteActions,R=(t=[])=>t.map(o=>{const n=C(o,!0),r=o.activityId;return{...n,id:r}}),g=t=>{var x,I,T,W,A,S;const o=t.workflowExecutionInfo.type.name,n=t.workflowExecutionInfo.execution.workflowId,r=t.workflowExecutionInfo.execution.runId,i=String(t.workflowExecutionInfo.startTime),c=String(t.workflowExecutionInfo.closeTime),a=t.workflowExecutionInfo.status,s=t.workflowExecutionInfo.status==="Running",u=t.workflowExecutionInfo.historyLength,l=`/workflows/${n}/${r}`,y=(I=(x=t==null?void 0:t.executionConfig)==null?void 0:x.taskQueue)==null?void 0:I.name,m=(T=t==null?void 0:t.workflowExecutionInfo)==null?void 0:T.parentNamespaceId,e=(W=t==null?void 0:t.workflowExecutionInfo)==null?void 0:W.parentExecution,k=t.workflowExecutionInfo.stateTransitionCount,h=(A=t.executionConfig)==null?void 0:A.defaultWorkflowTaskTimeout,E=R(t.pendingActivities),$=(S=t==null?void 0:t.pendingChildren)!=null?S:[];return{name:o,id:n,runId:r,startTime:i,endTime:c,status:a,historyEvents:u,url:l,taskQueue:y,pendingActivities:E,pendingChildren:$,parentNamespaceId:m,parent:e,stateTransitionCount:k,isRunning:s,defaultWorkflowTaskTimeout:h,get canBeTerminated(){return s&&N()}}},j=t=>(t.executions||[]).map(o=>g({workflowExecutionInfo:o})),q={workflowId:"WorkflowId",workflowType:"WorkflowType",timeRange:"StartTime",executionStatus:"ExecutionStatus",closeTime:"CloseTime"},U=["workflowId","workflowType","timeRange","executionStatus","closeTime"],L=t=>!(t===null||t===void 0||t===""||typeof t=="string"&&t==="undefined"),_=t=>{if(typeof t!="string")return!1;for(const o of U)if(o===t)return!0;return!1},V=(t,o,n)=>{const r=q[t];return o==="All"?"":z(o)||K(o)?n?`${r} > "${b(o)}"`:`${r} BETWEEN "${b(o)}" AND "${Q()}"`:`${r}="${o}"`},G=(t,o)=>Object.entries(t).map(([n,r])=>{if(_(n)&&L(r))return V(n,r,o)}).filter(Boolean),H=(t,o=!1)=>G(t,o).join(" and "),ot=async(t,o,n=fetch)=>{let r=0,i=0;try{const c=await w("workflows.count",{namespace:t});if(o){const a=f(c,{params:{query:o},onError:d,handleError:d,request:n}),s=f(c,{params:{query:""},onError:d,handleError:d,request:n}),[u,l]=await Promise.all([a,s]);i=u==null?void 0:u.count,r=l==null?void 0:l.count}else{const a=await f(c,{params:{},onError:d,handleError:d,request:n});r=a==null?void 0:a.count}}catch{}return{count:i,totalCount:r}},J=async(t,o,n=fetch,r=!1)=>{var m;const i=decodeURIComponent(o.query||H(o,r)),c=r?"workflows.archived":"workflows";let a="";const s=e=>{var k,h,E;F(e),((k=e==null?void 0:e.body)==null?void 0:k.message)||(e==null?void 0:e.status)?a=(E=(h=e==null?void 0:e.body)==null?void 0:h.message)!=null?E:`Error fetching workflows: ${e.status}: ${e.statusText}`:a="Error fetching workflows: Server failed to respond"},u=await w(c,{namespace:t}),{executions:l,nextPageToken:y}=(m=await f(u,{params:{query:i},onError:s,handleError:s,request:n}))!=null?m:{executions:[],nextPageToken:""};return{workflows:j({executions:l}),nextPageToken:String(y),error:a}},nt=async(t,o=fetch,n=!1)=>{const r=n?"workflows.archived":"workflows";let i=!0;const c=s=>{(D(s)||O(s))&&(i=!1)},a=await w(r,{namespace:t});return await f(a,{params:{pageSize:"1"},onError:c,handleError:c,request:o}),{authorized:i}},rt=async(t,o,n=fetch)=>J(t,o,n,!0);async function et(t,o=fetch){const n=await w("workflow",t);return f(n,{request:o}).then(g)}async function it({workflow:t,namespace:o,reason:n}){const r=await w("workflow.terminate",{namespace:o,workflowId:t.id,runId:t.runId});return await f(r,{options:{method:"POST",body:B({reason:n})},shouldRetry:!1,notifyOnError:!1})}async function at({namespace:t,workflowId:o,runId:n},r=fetch){const i=await w("workflow.cancel",{namespace:t,workflowId:o,runId:n});return f(i,{request:r,notifyOnError:!1,options:{method:"POST"}})}async function ct(t,o=fetch){const n=i=>{console.error(i)},r=await w("workflow",t);return f(r,{request:o,onError:n,handleError:n}).then(g)}export{H as a,J as b,at as c,ot as d,nt as e,et as f,rt as g,ct as h,it as t,N as w};
